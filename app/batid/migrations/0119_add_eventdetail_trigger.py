# Generated by Django 5.2.9 on 2025-12-15 17:00

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ("batid", "0118_add_eventdetail"),
    ]

    operations = [
        migrations.RunSQL(
            sql="""
            
            -- Function to compute the diff between a building and its previous version
            CREATE OR REPLACE FUNCTION public.compute_building_diff_from_last_version(
                building batid_building
            )
            RETURNS JSONB AS $$
            DECLARE
                prev_version RECORD;
                result JSONB := '{}'::jsonb;
                expected_columns TEXT[] := ARRAY[
                    'id', 'rnb_id', 'point', 'created_at', 'updated_at', 'shape',
                    'ext_ids', 'event_origin', 'sys_period', 'parent_buildings',
                    'status', 'event_id', 'event_type', 'event_user_id', 'is_active',
                    'addresses_id', 'revert_event_id'
                ];
                actual_columns TEXT[];
            BEGIN
                -- Assert that batid_building has exactly the expected columns
                -- This ensures we don't forget to update this function when new columns are added
                SELECT array_agg(key ORDER BY key)
                INTO actual_columns
                FROM jsonb_object_keys(to_jsonb(building)) AS key;

                IF actual_columns IS DISTINCT FROM (SELECT array_agg(c ORDER BY c) FROM unnest(expected_columns) AS c) THEN
                    RAISE EXCEPTION 'batid_building columns have changed. Expected: %, Got: %. Update compute_building_diff_from_last_version function to handle the new columns if necessary.',
                        (SELECT array_agg(c ORDER BY c) FROM unnest(expected_columns) AS c),
                        actual_columns;
                END IF;

                -- Fetch the most recent previous version from history
                SELECT * INTO prev_version
                FROM batid_building_history
                WHERE rnb_id = building.rnb_id
                ORDER BY upper(sys_period) DESC
                LIMIT 1;

                -- Compare point (prev_version.point is NULL if no previous version)
                IF prev_version.point IS DISTINCT FROM building.point THEN
                    result := result || jsonb_build_object(
                        'point',
                        jsonb_build_array(
                            CASE WHEN prev_version.point IS NULL THEN NULL ELSE ST_AsEWKT(prev_version.point) END,
                            CASE WHEN building.point IS NULL THEN NULL ELSE ST_AsEWKT(building.point) END
                        )
                    );
                END IF;

                -- Compare shape
                IF prev_version.shape IS DISTINCT FROM building.shape THEN
                    result := result || jsonb_build_object(
                        'shape',
                        jsonb_build_array(
                            CASE WHEN prev_version.shape IS NULL THEN NULL ELSE ST_AsEWKT(prev_version.shape) END,
                            CASE WHEN building.shape IS NULL THEN NULL ELSE ST_AsEWKT(building.shape) END
                        )
                    );
                END IF;

                -- Compare ext_ids
                IF prev_version.ext_ids IS DISTINCT FROM building.ext_ids THEN
                    result := result || jsonb_build_object(
                        'ext_ids',
                        jsonb_build_array(
                            prev_version.ext_ids,
                            building.ext_ids
                        )
                    );
                END IF;

                -- Compare is_active
                IF prev_version.is_active IS DISTINCT FROM building.is_active THEN
                    result := result || jsonb_build_object(
                        'is_active',
                        jsonb_build_array(prev_version.is_active, building.is_active)
                    );
                END IF;

                -- Compare addresses_id
                IF prev_version.addresses_id IS DISTINCT FROM building.addresses_id THEN
                    result := result || jsonb_build_object(
                        'addresses_id',
                        jsonb_build_array(
                            to_jsonb(prev_version.addresses_id),
                            to_jsonb(building.addresses_id)
                        )
                    );
                END IF;

                -- Compare status
                IF prev_version.status IS DISTINCT FROM building.status THEN
                    result := result || jsonb_build_object(
                        'status',
                        jsonb_build_array(prev_version.status, building.status)
                    );
                END IF;

                RETURN result;
            END;
            $$ LANGUAGE plpgsql;

            -- Create a function instead of just a trigger to be able to call it from outside (for instance for backfilling)
            CREATE OR REPLACE FUNCTION public.insert_or_update_event_detail(
                building batid_building
            )
            RETURNS VOID AS $$
            DECLARE
                v_city_id INTEGER;
                v_department_id INTEGER;
            BEGIN
                IF building.event_id IS NULL OR building.event_type IS NULL OR building.event_origin IS NULL OR building.point IS NULL THEN
                    RAISE EXCEPTION 'Missing required parameters';
                END IF;

                -- The building shape can overlap multiple cities and departments, but we keep a single one
                -- out of simplicity
                SELECT id INTO v_city_id
                FROM batid_city AS c
                WHERE ST_Intersects(c.shape, building.point)
                LIMIT 1;

                SELECT id INTO v_department_id
                FROM batid_department AS d
                WHERE ST_Intersects(d.shape, building.point)
                LIMIT 1;

                -- We don't specifically check out-of-bounds in the RNB, but I think we ordinarily want buildings to land in French territory
                IF v_city_id IS NULL OR v_department_id IS NULL THEN
                    RAISE EXCEPTION 'No city or department found for the building point';
                END IF;

                INSERT INTO batid_eventdetail (
                    event_id,
                    event_type,
                    event_origin,
                    city_id,
                    department_id,
                    user_id
                )
                VALUES (
                    building.event_id,
                    building.event_type,
                    building.event_origin,
                    v_city_id,
                    v_department_id,
                    building.event_user_id
                )
                ON CONFLICT (event_id) DO UPDATE SET
                    event_type = EXCLUDED.event_type,
                    event_origin = EXCLUDED.event_origin,
                    city_id = EXCLUDED.city_id,
                    department_id = EXCLUDED.department_id,
                    user_id = EXCLUDED.user_id;

                INSERT INTO batid_buildingeventdetail (
                    event_id,
                    rnb_id,
                    changes
                )
                VALUES (
                    building.event_id,
                    building.rnb_id,
                    compute_building_diff_from_last_version(building)
                );
            END;
            $$ LANGUAGE plpgsql;

            -- Helper function to convert batid_building_history row to batid_building and call insert_or_update_event_detail
            -- This is useful for backfilling from history table
            CREATE OR REPLACE FUNCTION public.insert_or_update_event_detail_from_history_row(
                history_row batid_building_history
            )
            RETURNS VOID AS $$
            BEGIN
                PERFORM insert_or_update_event_detail(
                    ROW(
                        history_row.id,
                        history_row.rnb_id,
                        history_row.point,
                        history_row.created_at,
                        history_row.updated_at,
                        history_row.shape,
                        history_row.ext_ids,
                        history_row.event_origin,
                        history_row.sys_period,
                        history_row.parent_buildings,
                        history_row.status,
                        history_row.event_id,
                        history_row.event_type,
                        history_row.event_user_id,
                        history_row.is_active,
                        history_row.addresses_id,
                        history_row.revert_event_id
                    )::batid_building
                );
            END;
            $$ LANGUAGE plpgsql;

            -- Trigger that calls the function
            CREATE OR REPLACE FUNCTION public.upsert_event_detail_trigger()
            RETURNS TRIGGER AS $$
            BEGIN
                PERFORM insert_or_update_event_detail(NEW);
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            -- Create unique index on event_id for the ON CONFLICT clause
            CREATE UNIQUE INDEX IF NOT EXISTS batid_eventdetail_event_id_unique
            ON batid_eventdetail (event_id);

            -- Create trigger for INSERT and UPDATE on batid_building
            -- Name it like this to make sure it executes after the versioning trigger
            CREATE TRIGGER building_versioning_trigger_1_insert_or_update_event_detail_trigger
            AFTER INSERT OR UPDATE ON batid_building
            FOR EACH ROW EXECUTE FUNCTION upsert_event_detail_trigger();
            """,
            reverse_sql="""
            DROP TRIGGER IF EXISTS building_versioning_trigger_1_insert_or_update_event_detail_trigger ON batid_building;
            DROP INDEX IF EXISTS batid_eventdetail_event_id_unique;
            DROP FUNCTION IF EXISTS public.upsert_event_detail_trigger();
            DROP FUNCTION IF EXISTS public.insert_or_update_event_detail_from_history_row(batid_building_history);
            DROP FUNCTION IF EXISTS public.insert_or_update_event_detail(batid_building);
            DROP FUNCTION IF EXISTS public.compute_building_diff_from_last_version(batid_building);
            """,
        ),
    ]
